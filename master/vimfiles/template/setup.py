:silent %s/<+PACKAGE+>/\=expand('%:p:h:t')/ge
:if isdirectory('.git')
:  silent /^#\s*>>*\s*Git/+1,/^#\s*<<*\s*Git/-1s/#\s//
:  silent g/^#\s*[<>]*\s*Git/d
:elseif isdirectory('.hg')
:  silent /^#\s*>>*\s*Mercurial/+1,/^#\s*<<*\s*Mercurial/-1s/#\s//
:  silent g/^#\s*[<>]*\s*Mercurial/d
:endif
:silent g/^#\s*>>*\s*\w\+/,/^#\s*<<*\s*\w\+/d
:if isdirectory('tests')
:  silent /#\s*>>*\s*discover/+2,/#\s*<<*\s*discover/-1s/#\s//
:  silent g/#\s*[<>]*\s*discover/d
:  silent g/#\s*>>*\s*simple/,/#\s*<<*\s*simple/d
:endif
#! /usr/bin/env python
#
# setup.py -- <+PACKAGE+> setup script
#

from __future__ import print_function
from distutils.command.build_scripts import build_scripts as _build_scripts
import os
import subprocess
import sys
import time

try:
    from setuptools import setup, Command

    setuptools = True
except ImportError:
    from distutils.core import setup, Command

    setuptools = False


def whence(cmd):
    cands = []
    if sys.platform == 'win32':
        cands.extend(cmd + ext for ext in ('.exe', '.bat', '.cmd'))
    cands.append(cmd)
    for p in os.environ['PATH'].split(os.pathsep):
        for n in cands:
            cmd = os.path.join(p, n)
            if os.path.isfile(cmd):
                return cmd


def exec_(argv, env=None):
    proc = subprocess.Popen(argv,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            env=env,
                            universal_newlines=True)
    out, err = proc.communicate()
    if proc.returncode:
        print('+', *argv, file=sys.stderr)
        for l in err.splitlines():
            print(l, file=sys.stderr)
        return ''
    return out


version = ''

# >>> Git
# if os.path.isdir('.git'):
#     env = {'LANGUAGE': 'C'}
#     if 'SystemRoot' in os.environ:
#         env['SystemRoot'] = os.environ['SystemRoot']
#     out = exec_([whence('git'), 'describe', '--tags', '--dirty=+', '--long', '--always'], env=env)
#     v = out.strip().rsplit('-', 2)
#     if len(v) == 3:
#         if v[1] == '0':
#             version = v[0]
#         else:
#             v[0] = v[0][1:]
#             version = '{}.{}'.format(*v)
#     else:
#         out = exec_([whence('git'), 'rev-list', 'HEAD', '--'], env=env)
#         version = '0.0.{}'.format(len(out.splitlines()) if out else '0')
#     if v[-1].endswith('+'):
#         version += time.strftime('+%Y-%m-%d')
# <<< Git
# >>> Mercurial
# if os.path.isdir('.hg'):
#     env = {'LANGUAGE': 'C'}
#     for k in ('PATH', 'SystemRoot'):
#         if k in os.environ:
#             env[k] = os.environ[k]
#     out = exec_([whence('hg'), 'id', '-it'], env=env).split()
#     id = out[0] if out else ''
#     for v in reversed(out[1:]):
#         if (v[0] == 'v' and
#             v[1].isdigit()):
#             break
#     else:
#         v = None
#     out = exec_([whence('hg'), 'log', '-r', '.', '-T', r'{latesttagdistance} {changessincelatesttag}\n'], env=env).split()
#     version = '{}.{}'.format(v[1:] if v else '0.0', out[-1] if out else '0')
#     if id.endswith('+'):
#         version += time.strftime('+%Y-%m-%d')
# elif os.path.isfile('.hg_archival.txt'):
#     with open('.hg_archival.txt') as fp:
#         meta = dict((s.strip() for s in l.split(':', 1))
#                     for l in fp)
#     if 'tag' in meta:
#         version = meta['tag']
#     elif 'latesttag' in meta:
#         tag = meta['latesttag'][1:] if meta['latesttag'] != 'null' else '0.0'
#         version = '{}.{}'.format(tag, meta.get('changessincelatesttag', meta['latesttagdistance']))
# <<< Mercurial

if version:
    with open(os.path.join('<+PACKAGE+>', '__version__.py'), 'w') as fp:
        stdout = sys.stdout
        try:
            sys.stdout = fp
            print('#')
            print('# <+PACKAGE+>.__version__')
            print('#')
            print('# this file is automatically generated by setup.py')
            print()
            print("version = '{}'".format(version))
        finally:
            sys.stdout = stdout
else:
    version = 'unknown'
    try:
        with open(os.path.join('<+PACKAGE+>', '__version__.py')) as fp:
            for l in fp:
                if l.startswith('version = '):
                    version = l.split('=', 1)[1].strip("\n '")
                    break
    except:
        pass


class build_scripts(_build_scripts):

    def run(self):
        for i, s in enumerate(self.scripts):
            p, m = os.path.split(s)
            s = '-'.join(s.strip('_') for s in m.split('.'))
            self.scripts[i] = os.path.join(p, s)
            if sys.platform == 'win32':
                self.scripts[i] += '.cmd'
                data = '@"{}" -m {} %*'
            else:
                data = '#! /bin/sh\nexec "{}" -m {} "$@"'

            self.mkpath(self.build_dir)
            with open(os.path.join(self.build_dir, s), 'w') as fp:
                print(data.format(sys.executable, m), file=fp)


class test(Command):

    description = 'run unit tests'
    user_options = [('failfast', 'f', 'stop on first fail or error')]

    boolean_options = ['failfast']

    def initialize_options(self):
        self.failfast = False

    def finalize_options(self):
        pass

    def run(self):
        import unittest

        if setuptools:
            if self.distribution.install_requires:
                self.distribution.fetch_build_eggs(self.distribution.install_requires)
            if self.distribution.tests_require:
                self.distribution.fetch_build_eggs(self.distribution.tests_require)
            self.run_command('egg_info')
        # >>> simple
        # run unittest
        # argv = [sys.argv[0]]
        # if self.verbose:
        #     argv.append('--verbose')
        # if self.failfast:
        #     argv.append('--failfast')
        # unittest.main('test_<+PACKAGE+>', argv=argv)
        # <<< simple
        # >>> discover
        # run unittest discover
        # argv = [sys.argv[0], 'discover', '--start-directory', 'tests']
        # if self.verbose:
        #     argv.append('--verbose')
        # if self.failfast:
        #     argv.append('--failfast')
        # unittest.main(None, argv=argv)
        # <<< discover


try:
    with open('README.rst') as fp:
        long_description = fp.read()
except:
    long_description = ''

packages = ['<+PACKAGE+>']
package_data = {}

cmdclass = {
    'test': test,
}

kwargs = {}
if setuptools:
    kwargs.update(install_requires=[],
                  tests_require=[],
                  entry_points={
                      'console_scripts': [
                          '<+PACKAGE+> = <+PACKAGE+>.__main__:main',
                      ]
                  })
else:
    cmdclass['build_scripts'] = build_scripts
    kwargs.update(scripts=[os.path.join('scripts', '<+PACKAGE+>')])
<+CURSOR+>
setup(name='<+PACKAGE+>',
      version=version,
      description='',
      long_description=long_description,
      author='Akinori Hattori',
      author_email='hattya@gmail.com',
      url='https://example.com/<+PACKAGE+>',
      license='',
      packages=packages,
      package_data=package_data,
      cmdclass=cmdclass,
      **kwargs)
